<!DOCTYPE html>
<html>
  <head>
　　 <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
　　 <title>
               Coroutines in C
           
    </title>
    <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Lato' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="/static/css/style.css"/>
    <link rel="stylesheet" href="/static/css/solarized_light.css">
    <script src="/static/js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      jax: ["input/TeX", "output/HTML-CSS"],
      tex2jax: {
        inlineMath: [ ['$', '$'] ],
        displayMath: [ ['$$', '$$']],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      messageStyle: "none",
      "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
    });
    </script>
    <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
　</head>

　<body>
    <div id="wrapper">
      <aside>
        <div class="site-info">lastmayday</div>
        <div class="index">
          <a href="/"><div class="circle home"><span>Home</span></div></a>
          <a href="/blog.html"><div class="circle blog"><span>Blog</span></div></a>
          <a href="/about.html"><div class="circle about"><span>About</span></div></a>
          <a href="/link.html"><div class="circle link"><span>Link</span></div></a>
        </div>
      </aside>
      <div class="content" role="main">
          <h1>Coroutines in C</h1>
          <div class="info">08 May 2014</div>
          <br />
          <p><a href="http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html">原文地址</a></p>

<p><br /></p>

<h2 id="section">引言</h2>

<p><br /></p>

<p>构造一个大型的程序经常是困难的工作. 其中一个问题经常是这样的: 如果你有一段代码产生数据, 有另外一段代码消费这些数据, 那么哪一段是调用者哪一段是被调用者呢?</p>

<p><br /></p>

<p>这里有一段非常简单的运行长度解压代码, 以及一段同样很简单的解析器代码:</p>
<pre>
<code class="c">
/* Decompression code */
while (1) {
    c = getchar();
    if (c == EOF)
        break;
    if (c == 0xFF) {
        len = getchar();
        c = getchar();
        while (len--)
            emit(c);
    } else
        emit(c);
}
emit(EOF);
</code>
</pre>

<p><br /></p>

<pre>
<code class="c">
/* Parser code */
while (1) {
    c = getchar();
    if (c == EOF)
        break;
    if (isalpha(c)) {
        do {
            add_to_token(c);
            c = getchar();
        } while (isalpha(c));
        got_token(WORD);
    }
    add_to_token(c);
    got_token(PUNCT);
}
</code>
</pre>

<p><br /></p>

<p>每一个代码片段都非常简单也很容易读懂理解. 一个每次通过调用<code>emit()</code>来产生一个字符; 另一个每次通过调用<code>getchar()</code>来消费一个字符. 如果<code>emit()</code>的调用和<code>getchar()</code>的调用可以相互提供数据, 那么很容易把这两个代码片段整合到一起, 这样解压器的输出就可以直接传递给解析器.</p>

<p><br /></p>

<p>在现代操作系统中, 你可以在两个进程或线程中使用管道(<code>pipes</code>)来达到这样. 解压器中的<code>emit()</code>向管道写数据, 解析器的<code>getchar()</code>从同一个管道的另一端读取数据. 简单粗暴, 但是也是重量级的而且不可移植. 通常你不想把你的程序划分成多个线程来做这样简单的任务.</p>

<p><br /></p>

<p>在这篇文章中, 我会为这样的架构问题提供一个创造性的解决方案.</p>

<p><br /></p>

<h2 id="section-1">重写</h2>

<p><br /></p>

<p>常规的答案是重写这个通信通道任一端的代码这样这个函数就可以被调用. 这里有一个分别针对每一个代码片段的简单例子.</p>

<pre>
<code class="c">
int decompressor(void) {
    static int repchar;
    static int replen;
    if (replen &gt; 0) {
        replen--;
        return repchar;
    }
    c = getchar();
    if (c == EOF)
        return EOF;
    if (c == 0xFF) {
        replen = getchar();
        repchar = getchar();
        replen--;
        return repchar;
    } else
        return c;
}
</code>
</pre>

<p><br /></p>

<pre>
<code class="c">
void parser(int c) {
    static enum {
        START, IN_WORD
    } state;
    switch (state) {
        case IN_WORD:
        if (isalpha(c)) {
            add_to_token(c);
            return;
        }
        got_token(WORD);
        state = START;
        /* fall through */

        case START:
        add_to_token(c);
        if (isalpha(c))
            state = IN_WORD;
        else
            got_token(PUNCT);
        break;
    }
}
</code>
</pre>

<p><br /></p>

<p>当然你不必重写两个; 一个就可以了. 如果你重写了上面的解压器, 那么每次调用的时候就会返回一个字符, 然后最初的解析器就可以把对<code>getchar()</code>的调用换成调用<code>decompressor()</code>, 然后程序就可以很高兴地运行了. 相反, 如果你重写了上面的解析器, 那么每输入一个字符就需要调用它一次, 然后最初的解压器就可以调用<code>parse()</code>而不是<code>emit()</code>. 如果你很贪吃的话可能会想要重写 <em>两个</em> 函数都作为被调用者.</p>

<p><br /></p>

<p>这就是要点, 真的. 这两个重写的函数相比它们之前都相当丑陋. 这里替换掉的进程写成调用者的时候比写成被调用者的时候要易读得多. 只是通过阅读代码, 试着推断解析器能识别的语法, 或者解压器可以理解的压缩过的数据格式, 你会发现最初的更清晰而且重写的这两个都没那么清晰. 如果我们没有把任何一段代码改成从内到外的话会好很多.</p>

<p><br /></p>

<h2 id="knuth">Knuth的协程</h2>

<p><br /></p>

<p>在 <em>The Art of Computer Programming</em> 这本书里, Donald Knuth展示了一个方法来解决这一类问题. 他的答案是完全抛弃栈的概念. 不要再想着一个进程作为调用者另一个进程作为被调用者, 而是开始把它们当作平等合作.</p>

<p><br /></p>

<p>具体而言: 把传统的”调用”原语替换成另一个略微不同的一个. 新的”调用”将会在某个地方而不是栈中保存返回值, 并且会直接跳到在另外一个保存的返回值中指定的地方. 所以每次解压器产生另外一个字符, 它就保存了它的程序计数器(program counter)并且跳转到解析器中的最后一个已知的位置 - 而每次解析器 <em>需要</em> 另外一个字符, 它就保存它自己的程序计数器然后跳转到解压器保存的位置. 控制权在这两个例程之间尽可能需要地来回交换.</p>

<p><br /></p>

<p>理论上十分美好, 但实际上你只能在汇编语言中这样做, 因为没有常用的高级语言支持协程调用原语. 像C一样的语言完全取决于它们基于栈的结构, 所以无论什么时候控制权从一个函数到另一个函数的话, 一个函数就必须是调用者而另外一个就必须是被调用者. 所以如果你想写可移植的代码, 这个技术至少像Unix的管道方法一样不切实际.</p>

<p><br /></p>

<h2 id="section-2">基于栈的协程</h2>

<p><br /></p>

<p>所以我们 <em>真正</em> 想要的是用C语言来模仿Knuth的协程调用原语的能力. 我们必须接受这个事实, 在C语言层次, 一个函数将是调用者而另一个函数是被调用者. 在调用者中, 我们没有问题; 我们编写最初的算法, 就像开始写的那样, 然后无论什么时候它需要一个字符的时候就调用其他的函数.</p>

<p><br /></p>

<p>被调用者有许多问题. 对于被调用的函数, 我们想要一个有”return and continue”的操作的函数; 从函数返回, 并且下一次被调用的时候, 正好从 <em>return</em> 语句之后恢复控制. 例如, 我们想要写一个这样的函数</p>

<pre>
<code class="c">
int function(void) {
    int i;
    for (i = 0; i &lt; 10; i++)
        return i;   /* won't work, but wouldn't it be nice */
}
</code>
</pre>
<p>并且有10次成功的调用, 分别返回0-9.</p>

<p><br /></p>

<p>我们怎样实践? 好吧, 我们可以使用<code>goto</code>语句把控制权交给任意一点. 所以如果我们使用一个state变量, 我们可以这样做:</p>
<pre>
<code class="c">
int function(void) {
    static int i, state = 0;
    switch (state) {
        case 0: goto LABEL0;
        case 1: goto LABEL1;
    }
    LABEL0: /* start of function */
    for (i = 0; i &lt; 10; i++) {
        state = 1; /* so we will come back to LABEL1 */
        return i;
        LABEL1:; /* resume control straight after the return */
    }
}
</code>
</pre>

<p><br /></p>

<p>这个方法就可以工作了. 我们有一系列标签来指出我们可能会需要恢复控制的地方: 一个在最开始, 一个在每一个<code>return</code>语句后面. 我们有一个状态变量, 保存在函数调用之间, 这个变量告诉我们接下来我们需要把控制恢复到哪个标签. 在返回任何东西之前, 我们更新这个状态变量使它指向正确的标签; 在任何调用之后, 我们依据这个变量的值来使用<code>switch</code>, 找出我们需要跳转到哪儿.</p>

<p><br /></p>

<p>但是这种方法仍然很丑. 它最糟糕的部分是必须手动维持这一系列标签, 而且必须在函数体与初始的<code>switch</code>语句之间保持一致. 每次我们增加一个新的返回语句, 我们必须发明一个新的标签名并且把它添加到<code>switch</code>列表中; 每次我们移除一个返回语句, 我们必须移除它对应的标签. 我们已经增加了两倍的维护负担.</p>

<p><br /></p>

<h2 id="duffs-device">Duff’s device</h2>

<p>C语言中著名的<a href="http://zh.wikipedia.org/wiki/%E8%BE%BE%E5%A4%AB%E8%AE%BE%E5%A4%87">“Duff’s device”</a>利用了一个<code>case</code>语句也是它对应的<code>switch</code>语句的合法子块这个事实. Tom Duff使用这个来优化循环:</p>
<pre>
<code class="c">
switch (count % 8) {
    case 0:        do {  *to = *from++;
    case 7:              *to = *from++;
    case 6:              *to = *from++;
    case 5:              *to = *from++;
    case 4:              *to = *from++;
    case 3:              *to = *from++;
    case 2:              *to = *from++;
    case 1:              *to = *from++;
                   } while ((count -= 8) &gt; 0);
}
</code>
</pre>

<p><br /></p>

<p>我们可以在协程的技巧中略微不同地使用这种方法. 不使用<code>switch</code>语句来决定执行哪一个<code>goto</code>语句, 我们使用<code>switch</code>语句本身就可以跳转:</p>
<pre>
<code class="c">
int function(void) {
    static int i, state = 0;
    switch (state) {
        case 0: /* start of function */
        for (i = 0; i &lt; 10; i++) {
            state = 1; /* so we will come back to "case 1" */
            return i;
            case 1:; /* resume control straight after the return */
        }
    }
}
</code>
</pre>

<p><br /></p>

<p>现在看起来有希望多啦. 接下来我们需要做的就是构造一些精心挑选的宏, 这样我们可以用看上去合理的东西来隐藏血淋淋的细节:</p>
<pre>
<code class="c">
#define crBegin static int state=0; switch(state) { case 0:
#define crReturn(i,x) do { state=i; return x; case i:; } while (0)
#define crFinish }
int function(void) {
    static int i;
    crBegin;
    for (i = 0; i &lt; 10; i++)
        crReturn(1, i);
    crFinish;
}
</code>
</pre>

<p>(注意<code>do ... while(0)</code>的使用来保证<code>crReturn</code>在<code>if</code>和<code>else</code>中间直接出现的时候不需要括号包围)</p>

<p><br /></p>

<p>这几乎就是我们想要的了. 我们可以使用<code>crReturn</code>这样从函数返回, 下一次调用的控制权正好在return之后. 当然我们必须遵守一些基本规则(在函数体周围有<code>crBegin</code>和<code>crFinish</code>); 把所有需要通过<code>crReturn</code>保存的局部变量都声明成<code>static</code>; <em>从不</em> 把一个<code>crReturn</code>放在一个明确的<code>switch</code>语句中; 但是这些并没有限制我们很多.</p>

<p><br /></p>

<p>剩下的唯一一个钉子是<code>crReturn</code>的第一个参数. 就像当我们在前一个部分中发明一个新标签时我们不得不避免它和现有的标签名冲突, 现在我们必须保证我们给<code>crReturn</code>的状态参数都不一样. 后果会相当良性 - 计算机会捕捉到它并且不会在执行的时候发生可怕的事情 - 但是我们还是要避免这样做.</p>

<p><br /></p>

<p>即使这也是可以解决的. ANSI C 提供了特殊的宏名<code>__LINE__</code> , 它扩展到当前源码的行号. 所以我们可以把<code>crReturn</code>重写成</p>
<pre>
<code class="c">
#define crReturn(x) do { state=__LINE__; return x; \
                         case __LINE__:; } while (0)
</code>
</pre>

<p>然后我们可以不用再担心这些声明参数了, 只要我们遵守第四个基本规则(从不把两个<code>crReturn</code>语句放在同一行).</p>

<p><br /></p>

<h2 id="section-3">评价</h2>

<p><br /></p>



          
          <div class="tags">
            <span>标签: </span>
            <ul>
            
              <li>C</li>
            
            </ul>
          </div>
          
          <div id="disqus_thread"></div>
          <script type="text/javascript">
            var disqus_shortname = 'lastmayday-github'; // required: replace example with your forum shortname
            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
              var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
              dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
              (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
          </script>
          <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
          <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      </div>
      <footer role="contentinfo">
        <p>Powered by <a href="http://jekyllrb.com/">Jekyll</a> and <a href="http://pages.github.com/">Github Pages</a></p>
        <p> &copy lastmayday 2013-2014 | All Rights Reserved. </p>
      </footer>
    </div>
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-38333678-2']);
      _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </body>
</html>
